// +build !ignore_autogenerated_openshift

// This file was autogenerated by deepcopy-gen. Do not edit it manually!

package api

import (
	pkg_api "k8s.io/kubernetes/pkg/api"
	unversioned "k8s.io/kubernetes/pkg/api/unversioned"
	conversion "k8s.io/kubernetes/pkg/conversion"
	runtime "k8s.io/kubernetes/pkg/runtime"
	reflect "reflect"
)

func init() {
	SchemeBuilder.Register(RegisterDeepCopies)
}

// RegisterDeepCopies adds deep-copy functions to the given scheme. Public
// to allow building arbitrary schemes.
func RegisterDeepCopies(scheme *runtime.Scheme) error {
	return scheme.AddGeneratedDeepCopyFuncs(
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Descriptor, InType: reflect.TypeOf(&Descriptor{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DockerConfig, InType: reflect.TypeOf(&DockerConfig{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DockerConfigHistory, InType: reflect.TypeOf(&DockerConfigHistory{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DockerConfigRootFS, InType: reflect.TypeOf(&DockerConfigRootFS{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DockerFSLayer, InType: reflect.TypeOf(&DockerFSLayer{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DockerHistory, InType: reflect.TypeOf(&DockerHistory{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DockerImage, InType: reflect.TypeOf(&DockerImage{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DockerImageConfig, InType: reflect.TypeOf(&DockerImageConfig{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DockerImageManifest, InType: reflect.TypeOf(&DockerImageManifest{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DockerImageReference, InType: reflect.TypeOf(&DockerImageReference{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DockerV1CompatibilityImage, InType: reflect.TypeOf(&DockerV1CompatibilityImage{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_DockerV1CompatibilityImageSize, InType: reflect.TypeOf(&DockerV1CompatibilityImageSize{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_Image, InType: reflect.TypeOf(&Image{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ImageImportSpec, InType: reflect.TypeOf(&ImageImportSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ImageImportStatus, InType: reflect.TypeOf(&ImageImportStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ImageLayer, InType: reflect.TypeOf(&ImageLayer{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ImageList, InType: reflect.TypeOf(&ImageList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ImageSignature, InType: reflect.TypeOf(&ImageSignature{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ImageStream, InType: reflect.TypeOf(&ImageStream{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ImageStreamImage, InType: reflect.TypeOf(&ImageStreamImage{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ImageStreamImport, InType: reflect.TypeOf(&ImageStreamImport{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ImageStreamImportSpec, InType: reflect.TypeOf(&ImageStreamImportSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ImageStreamImportStatus, InType: reflect.TypeOf(&ImageStreamImportStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ImageStreamList, InType: reflect.TypeOf(&ImageStreamList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ImageStreamMapping, InType: reflect.TypeOf(&ImageStreamMapping{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ImageStreamSpec, InType: reflect.TypeOf(&ImageStreamSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ImageStreamStatus, InType: reflect.TypeOf(&ImageStreamStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ImageStreamTag, InType: reflect.TypeOf(&ImageStreamTag{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_ImageStreamTagList, InType: reflect.TypeOf(&ImageStreamTagList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_RepositoryImportSpec, InType: reflect.TypeOf(&RepositoryImportSpec{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_RepositoryImportStatus, InType: reflect.TypeOf(&RepositoryImportStatus{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_SignatureCondition, InType: reflect.TypeOf(&SignatureCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_SignatureGenericEntity, InType: reflect.TypeOf(&SignatureGenericEntity{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_SignatureIssuer, InType: reflect.TypeOf(&SignatureIssuer{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_SignatureSubject, InType: reflect.TypeOf(&SignatureSubject{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_TagEvent, InType: reflect.TypeOf(&TagEvent{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_TagEventCondition, InType: reflect.TypeOf(&TagEventCondition{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_TagEventList, InType: reflect.TypeOf(&TagEventList{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_TagImportPolicy, InType: reflect.TypeOf(&TagImportPolicy{})},
		conversion.GeneratedDeepCopyFunc{Fn: DeepCopy_api_TagReference, InType: reflect.TypeOf(&TagReference{})},
	)
}

func DeepCopy_api_Descriptor(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Descriptor)
		out := out.(*Descriptor)
		out.MediaType = in.MediaType
		out.Size = in.Size
		out.Digest = in.Digest
		return nil
	}
}

func DeepCopy_api_DockerConfig(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DockerConfig)
		out := out.(*DockerConfig)
		out.Hostname = in.Hostname
		out.Domainname = in.Domainname
		out.User = in.User
		out.Memory = in.Memory
		out.MemorySwap = in.MemorySwap
		out.CPUShares = in.CPUShares
		out.CPUSet = in.CPUSet
		out.AttachStdin = in.AttachStdin
		out.AttachStdout = in.AttachStdout
		out.AttachStderr = in.AttachStderr
		if in.PortSpecs != nil {
			in, out := &in.PortSpecs, &out.PortSpecs
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.PortSpecs = nil
		}
		if in.ExposedPorts != nil {
			in, out := &in.ExposedPorts, &out.ExposedPorts
			*out = make(map[string]struct{})
			for key := range *in {
				(*out)[key] = struct{}{}
			}
		} else {
			out.ExposedPorts = nil
		}
		out.Tty = in.Tty
		out.OpenStdin = in.OpenStdin
		out.StdinOnce = in.StdinOnce
		if in.Env != nil {
			in, out := &in.Env, &out.Env
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.Env = nil
		}
		if in.Cmd != nil {
			in, out := &in.Cmd, &out.Cmd
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.Cmd = nil
		}
		if in.DNS != nil {
			in, out := &in.DNS, &out.DNS
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.DNS = nil
		}
		out.Image = in.Image
		if in.Volumes != nil {
			in, out := &in.Volumes, &out.Volumes
			*out = make(map[string]struct{})
			for key := range *in {
				(*out)[key] = struct{}{}
			}
		} else {
			out.Volumes = nil
		}
		out.VolumesFrom = in.VolumesFrom
		out.WorkingDir = in.WorkingDir
		if in.Entrypoint != nil {
			in, out := &in.Entrypoint, &out.Entrypoint
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.Entrypoint = nil
		}
		out.NetworkDisabled = in.NetworkDisabled
		if in.SecurityOpts != nil {
			in, out := &in.SecurityOpts, &out.SecurityOpts
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.SecurityOpts = nil
		}
		if in.OnBuild != nil {
			in, out := &in.OnBuild, &out.OnBuild
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.OnBuild = nil
		}
		if in.Labels != nil {
			in, out := &in.Labels, &out.Labels
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		} else {
			out.Labels = nil
		}
		return nil
	}
}

func DeepCopy_api_DockerConfigHistory(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DockerConfigHistory)
		out := out.(*DockerConfigHistory)
		out.Created = in.Created.DeepCopy()
		out.Author = in.Author
		out.CreatedBy = in.CreatedBy
		out.Comment = in.Comment
		out.EmptyLayer = in.EmptyLayer
		return nil
	}
}

func DeepCopy_api_DockerConfigRootFS(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DockerConfigRootFS)
		out := out.(*DockerConfigRootFS)
		out.Type = in.Type
		if in.DiffIDs != nil {
			in, out := &in.DiffIDs, &out.DiffIDs
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.DiffIDs = nil
		}
		return nil
	}
}

func DeepCopy_api_DockerFSLayer(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DockerFSLayer)
		out := out.(*DockerFSLayer)
		out.DockerBlobSum = in.DockerBlobSum
		return nil
	}
}

func DeepCopy_api_DockerHistory(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DockerHistory)
		out := out.(*DockerHistory)
		out.DockerV1Compatibility = in.DockerV1Compatibility
		return nil
	}
}

func DeepCopy_api_DockerImage(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DockerImage)
		out := out.(*DockerImage)
		out.TypeMeta = in.TypeMeta
		out.ID = in.ID
		out.Parent = in.Parent
		out.Comment = in.Comment
		out.Created = in.Created.DeepCopy()
		out.Container = in.Container
		if err := DeepCopy_api_DockerConfig(&in.ContainerConfig, &out.ContainerConfig, c); err != nil {
			return err
		}
		out.DockerVersion = in.DockerVersion
		out.Author = in.Author
		if in.Config != nil {
			in, out := &in.Config, &out.Config
			*out = new(DockerConfig)
			if err := DeepCopy_api_DockerConfig(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.Config = nil
		}
		out.Architecture = in.Architecture
		out.Size = in.Size
		return nil
	}
}

func DeepCopy_api_DockerImageConfig(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DockerImageConfig)
		out := out.(*DockerImageConfig)
		out.ID = in.ID
		out.Parent = in.Parent
		out.Comment = in.Comment
		out.Created = in.Created.DeepCopy()
		out.Container = in.Container
		if err := DeepCopy_api_DockerConfig(&in.ContainerConfig, &out.ContainerConfig, c); err != nil {
			return err
		}
		out.DockerVersion = in.DockerVersion
		out.Author = in.Author
		if in.Config != nil {
			in, out := &in.Config, &out.Config
			*out = new(DockerConfig)
			if err := DeepCopy_api_DockerConfig(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.Config = nil
		}
		out.Architecture = in.Architecture
		out.Size = in.Size
		if in.RootFS != nil {
			in, out := &in.RootFS, &out.RootFS
			*out = new(DockerConfigRootFS)
			if err := DeepCopy_api_DockerConfigRootFS(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.RootFS = nil
		}
		if in.History != nil {
			in, out := &in.History, &out.History
			*out = make([]DockerConfigHistory, len(*in))
			for i := range *in {
				if err := DeepCopy_api_DockerConfigHistory(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.History = nil
		}
		out.OSVersion = in.OSVersion
		if in.OSFeatures != nil {
			in, out := &in.OSFeatures, &out.OSFeatures
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.OSFeatures = nil
		}
		return nil
	}
}

func DeepCopy_api_DockerImageManifest(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DockerImageManifest)
		out := out.(*DockerImageManifest)
		out.SchemaVersion = in.SchemaVersion
		out.MediaType = in.MediaType
		out.Name = in.Name
		out.Tag = in.Tag
		out.Architecture = in.Architecture
		if in.FSLayers != nil {
			in, out := &in.FSLayers, &out.FSLayers
			*out = make([]DockerFSLayer, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.FSLayers = nil
		}
		if in.History != nil {
			in, out := &in.History, &out.History
			*out = make([]DockerHistory, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.History = nil
		}
		if in.Layers != nil {
			in, out := &in.Layers, &out.Layers
			*out = make([]Descriptor, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.Layers = nil
		}
		out.Config = in.Config
		return nil
	}
}

func DeepCopy_api_DockerImageReference(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DockerImageReference)
		out := out.(*DockerImageReference)
		out.Registry = in.Registry
		out.Namespace = in.Namespace
		out.Name = in.Name
		out.Tag = in.Tag
		out.ID = in.ID
		return nil
	}
}

func DeepCopy_api_DockerV1CompatibilityImage(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DockerV1CompatibilityImage)
		out := out.(*DockerV1CompatibilityImage)
		out.ID = in.ID
		out.Parent = in.Parent
		out.Comment = in.Comment
		out.Created = in.Created.DeepCopy()
		out.Container = in.Container
		if err := DeepCopy_api_DockerConfig(&in.ContainerConfig, &out.ContainerConfig, c); err != nil {
			return err
		}
		out.DockerVersion = in.DockerVersion
		out.Author = in.Author
		if in.Config != nil {
			in, out := &in.Config, &out.Config
			*out = new(DockerConfig)
			if err := DeepCopy_api_DockerConfig(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.Config = nil
		}
		out.Architecture = in.Architecture
		out.Size = in.Size
		return nil
	}
}

func DeepCopy_api_DockerV1CompatibilityImageSize(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*DockerV1CompatibilityImageSize)
		out := out.(*DockerV1CompatibilityImageSize)
		out.Size = in.Size
		return nil
	}
}

func DeepCopy_api_Image(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*Image)
		out := out.(*Image)
		out.TypeMeta = in.TypeMeta
		if err := pkg_api.DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		out.DockerImageReference = in.DockerImageReference
		if err := DeepCopy_api_DockerImage(&in.DockerImageMetadata, &out.DockerImageMetadata, c); err != nil {
			return err
		}
		out.DockerImageMetadataVersion = in.DockerImageMetadataVersion
		out.DockerImageManifest = in.DockerImageManifest
		if in.DockerImageLayers != nil {
			in, out := &in.DockerImageLayers, &out.DockerImageLayers
			*out = make([]ImageLayer, len(*in))
			for i := range *in {
				(*out)[i] = (*in)[i]
			}
		} else {
			out.DockerImageLayers = nil
		}
		if in.Signatures != nil {
			in, out := &in.Signatures, &out.Signatures
			*out = make([]ImageSignature, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ImageSignature(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Signatures = nil
		}
		if in.DockerImageSignatures != nil {
			in, out := &in.DockerImageSignatures, &out.DockerImageSignatures
			*out = make([][]byte, len(*in))
			for i := range *in {
				if newVal, err := c.DeepCopy(&(*in)[i]); err != nil {
					return err
				} else {
					(*out)[i] = *newVal.(*[]byte)
				}
			}
		} else {
			out.DockerImageSignatures = nil
		}
		out.DockerImageManifestMediaType = in.DockerImageManifestMediaType
		out.DockerImageConfig = in.DockerImageConfig
		return nil
	}
}

func DeepCopy_api_ImageImportSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ImageImportSpec)
		out := out.(*ImageImportSpec)
		out.From = in.From
		if in.To != nil {
			in, out := &in.To, &out.To
			*out = new(pkg_api.LocalObjectReference)
			**out = **in
		} else {
			out.To = nil
		}
		out.ImportPolicy = in.ImportPolicy
		out.IncludeManifest = in.IncludeManifest
		return nil
	}
}

func DeepCopy_api_ImageImportStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ImageImportStatus)
		out := out.(*ImageImportStatus)
		out.Tag = in.Tag
		if err := unversioned.DeepCopy_unversioned_Status(&in.Status, &out.Status, c); err != nil {
			return err
		}
		if in.Image != nil {
			in, out := &in.Image, &out.Image
			*out = new(Image)
			if err := DeepCopy_api_Image(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.Image = nil
		}
		return nil
	}
}

func DeepCopy_api_ImageLayer(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ImageLayer)
		out := out.(*ImageLayer)
		out.Name = in.Name
		out.LayerSize = in.LayerSize
		out.MediaType = in.MediaType
		return nil
	}
}

func DeepCopy_api_ImageList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ImageList)
		out := out.(*ImageList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]Image, len(*in))
			for i := range *in {
				if err := DeepCopy_api_Image(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_ImageSignature(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ImageSignature)
		out := out.(*ImageSignature)
		out.TypeMeta = in.TypeMeta
		if err := pkg_api.DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		out.Type = in.Type
		if in.Content != nil {
			in, out := &in.Content, &out.Content
			*out = make([]byte, len(*in))
			copy(*out, *in)
		} else {
			out.Content = nil
		}
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]SignatureCondition, len(*in))
			for i := range *in {
				if err := DeepCopy_api_SignatureCondition(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Conditions = nil
		}
		out.ImageIdentity = in.ImageIdentity
		if in.SignedClaims != nil {
			in, out := &in.SignedClaims, &out.SignedClaims
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		} else {
			out.SignedClaims = nil
		}
		if in.Created != nil {
			in, out := &in.Created, &out.Created
			*out = new(unversioned.Time)
			**out = (*in).DeepCopy()
		} else {
			out.Created = nil
		}
		if in.IssuedBy != nil {
			in, out := &in.IssuedBy, &out.IssuedBy
			*out = new(SignatureIssuer)
			**out = **in
		} else {
			out.IssuedBy = nil
		}
		if in.IssuedTo != nil {
			in, out := &in.IssuedTo, &out.IssuedTo
			*out = new(SignatureSubject)
			**out = **in
		} else {
			out.IssuedTo = nil
		}
		return nil
	}
}

func DeepCopy_api_ImageStream(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ImageStream)
		out := out.(*ImageStream)
		out.TypeMeta = in.TypeMeta
		if err := pkg_api.DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ImageStreamSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ImageStreamStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_ImageStreamImage(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ImageStreamImage)
		out := out.(*ImageStreamImage)
		out.TypeMeta = in.TypeMeta
		if err := pkg_api.DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_Image(&in.Image, &out.Image, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_ImageStreamImport(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ImageStreamImport)
		out := out.(*ImageStreamImport)
		out.TypeMeta = in.TypeMeta
		if err := pkg_api.DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ImageStreamImportSpec(&in.Spec, &out.Spec, c); err != nil {
			return err
		}
		if err := DeepCopy_api_ImageStreamImportStatus(&in.Status, &out.Status, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_ImageStreamImportSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ImageStreamImportSpec)
		out := out.(*ImageStreamImportSpec)
		out.Import = in.Import
		if in.Repository != nil {
			in, out := &in.Repository, &out.Repository
			*out = new(RepositoryImportSpec)
			**out = **in
		} else {
			out.Repository = nil
		}
		if in.Images != nil {
			in, out := &in.Images, &out.Images
			*out = make([]ImageImportSpec, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ImageImportSpec(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Images = nil
		}
		return nil
	}
}

func DeepCopy_api_ImageStreamImportStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ImageStreamImportStatus)
		out := out.(*ImageStreamImportStatus)
		if in.Import != nil {
			in, out := &in.Import, &out.Import
			*out = new(ImageStream)
			if err := DeepCopy_api_ImageStream(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.Import = nil
		}
		if in.Repository != nil {
			in, out := &in.Repository, &out.Repository
			*out = new(RepositoryImportStatus)
			if err := DeepCopy_api_RepositoryImportStatus(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.Repository = nil
		}
		if in.Images != nil {
			in, out := &in.Images, &out.Images
			*out = make([]ImageImportStatus, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ImageImportStatus(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Images = nil
		}
		return nil
	}
}

func DeepCopy_api_ImageStreamList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ImageStreamList)
		out := out.(*ImageStreamList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]ImageStream, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ImageStream(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_ImageStreamMapping(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ImageStreamMapping)
		out := out.(*ImageStreamMapping)
		out.TypeMeta = in.TypeMeta
		if err := pkg_api.DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		out.DockerImageRepository = in.DockerImageRepository
		if err := DeepCopy_api_Image(&in.Image, &out.Image, c); err != nil {
			return err
		}
		out.Tag = in.Tag
		return nil
	}
}

func DeepCopy_api_ImageStreamSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ImageStreamSpec)
		out := out.(*ImageStreamSpec)
		out.DockerImageRepository = in.DockerImageRepository
		if in.Tags != nil {
			in, out := &in.Tags, &out.Tags
			*out = make(map[string]TagReference)
			for key, val := range *in {
				newVal := new(TagReference)
				if err := DeepCopy_api_TagReference(&val, newVal, c); err != nil {
					return err
				}
				(*out)[key] = *newVal
			}
		} else {
			out.Tags = nil
		}
		return nil
	}
}

func DeepCopy_api_ImageStreamStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ImageStreamStatus)
		out := out.(*ImageStreamStatus)
		out.DockerImageRepository = in.DockerImageRepository
		if in.Tags != nil {
			in, out := &in.Tags, &out.Tags
			*out = make(map[string]TagEventList)
			for key, val := range *in {
				newVal := new(TagEventList)
				if err := DeepCopy_api_TagEventList(&val, newVal, c); err != nil {
					return err
				}
				(*out)[key] = *newVal
			}
		} else {
			out.Tags = nil
		}
		return nil
	}
}

func DeepCopy_api_ImageStreamTag(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ImageStreamTag)
		out := out.(*ImageStreamTag)
		out.TypeMeta = in.TypeMeta
		if err := pkg_api.DeepCopy_api_ObjectMeta(&in.ObjectMeta, &out.ObjectMeta, c); err != nil {
			return err
		}
		if in.Tag != nil {
			in, out := &in.Tag, &out.Tag
			*out = new(TagReference)
			if err := DeepCopy_api_TagReference(*in, *out, c); err != nil {
				return err
			}
		} else {
			out.Tag = nil
		}
		out.Generation = in.Generation
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]TagEventCondition, len(*in))
			for i := range *in {
				if err := DeepCopy_api_TagEventCondition(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Conditions = nil
		}
		if err := DeepCopy_api_Image(&in.Image, &out.Image, c); err != nil {
			return err
		}
		return nil
	}
}

func DeepCopy_api_ImageStreamTagList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*ImageStreamTagList)
		out := out.(*ImageStreamTagList)
		out.TypeMeta = in.TypeMeta
		out.ListMeta = in.ListMeta
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]ImageStreamTag, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ImageStreamTag(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		return nil
	}
}

func DeepCopy_api_RepositoryImportSpec(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*RepositoryImportSpec)
		out := out.(*RepositoryImportSpec)
		out.From = in.From
		out.ImportPolicy = in.ImportPolicy
		out.IncludeManifest = in.IncludeManifest
		return nil
	}
}

func DeepCopy_api_RepositoryImportStatus(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*RepositoryImportStatus)
		out := out.(*RepositoryImportStatus)
		if err := unversioned.DeepCopy_unversioned_Status(&in.Status, &out.Status, c); err != nil {
			return err
		}
		if in.Images != nil {
			in, out := &in.Images, &out.Images
			*out = make([]ImageImportStatus, len(*in))
			for i := range *in {
				if err := DeepCopy_api_ImageImportStatus(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Images = nil
		}
		if in.AdditionalTags != nil {
			in, out := &in.AdditionalTags, &out.AdditionalTags
			*out = make([]string, len(*in))
			copy(*out, *in)
		} else {
			out.AdditionalTags = nil
		}
		return nil
	}
}

func DeepCopy_api_SignatureCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SignatureCondition)
		out := out.(*SignatureCondition)
		out.Type = in.Type
		out.Status = in.Status
		out.LastProbeTime = in.LastProbeTime.DeepCopy()
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
		out.Reason = in.Reason
		out.Message = in.Message
		return nil
	}
}

func DeepCopy_api_SignatureGenericEntity(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SignatureGenericEntity)
		out := out.(*SignatureGenericEntity)
		out.Organization = in.Organization
		out.CommonName = in.CommonName
		return nil
	}
}

func DeepCopy_api_SignatureIssuer(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SignatureIssuer)
		out := out.(*SignatureIssuer)
		out.SignatureGenericEntity = in.SignatureGenericEntity
		return nil
	}
}

func DeepCopy_api_SignatureSubject(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*SignatureSubject)
		out := out.(*SignatureSubject)
		out.SignatureGenericEntity = in.SignatureGenericEntity
		out.PublicKeyID = in.PublicKeyID
		return nil
	}
}

func DeepCopy_api_TagEvent(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*TagEvent)
		out := out.(*TagEvent)
		out.Created = in.Created.DeepCopy()
		out.DockerImageReference = in.DockerImageReference
		out.Image = in.Image
		out.Generation = in.Generation
		return nil
	}
}

func DeepCopy_api_TagEventCondition(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*TagEventCondition)
		out := out.(*TagEventCondition)
		out.Type = in.Type
		out.Status = in.Status
		out.LastTransitionTime = in.LastTransitionTime.DeepCopy()
		out.Reason = in.Reason
		out.Message = in.Message
		out.Generation = in.Generation
		return nil
	}
}

func DeepCopy_api_TagEventList(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*TagEventList)
		out := out.(*TagEventList)
		if in.Items != nil {
			in, out := &in.Items, &out.Items
			*out = make([]TagEvent, len(*in))
			for i := range *in {
				if err := DeepCopy_api_TagEvent(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Items = nil
		}
		if in.Conditions != nil {
			in, out := &in.Conditions, &out.Conditions
			*out = make([]TagEventCondition, len(*in))
			for i := range *in {
				if err := DeepCopy_api_TagEventCondition(&(*in)[i], &(*out)[i], c); err != nil {
					return err
				}
			}
		} else {
			out.Conditions = nil
		}
		return nil
	}
}

func DeepCopy_api_TagImportPolicy(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*TagImportPolicy)
		out := out.(*TagImportPolicy)
		out.Insecure = in.Insecure
		out.Scheduled = in.Scheduled
		return nil
	}
}

func DeepCopy_api_TagReference(in interface{}, out interface{}, c *conversion.Cloner) error {
	{
		in := in.(*TagReference)
		out := out.(*TagReference)
		out.Name = in.Name
		if in.Annotations != nil {
			in, out := &in.Annotations, &out.Annotations
			*out = make(map[string]string)
			for key, val := range *in {
				(*out)[key] = val
			}
		} else {
			out.Annotations = nil
		}
		if in.From != nil {
			in, out := &in.From, &out.From
			*out = new(pkg_api.ObjectReference)
			**out = **in
		} else {
			out.From = nil
		}
		out.Reference = in.Reference
		if in.Generation != nil {
			in, out := &in.Generation, &out.Generation
			*out = new(int64)
			**out = **in
		} else {
			out.Generation = nil
		}
		out.ImportPolicy = in.ImportPolicy
		return nil
	}
}
